\documentclass[specialist,
substylefile = spbu.rtx,
subf,href,colorlinks=true, 12pt]{disser}

\usepackage[a4paper,
mag=1000, includefoot,
left=3cm, right=1.5cm, top=2cm, bottom=2cm, headsep=1cm, footskip=1cm]{geometry}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[lined,linesnumbered]{algorithm2e}
\ifpdf\usepackage{epstopdf}\fi
\let\vec=\mathbf
\setcounter{tocdepth}{2}
\graphicspath{{fig/}}
\SetAlgorithmName{Алгоритм}{alg}{Список алгоритмов}
\usepackage{etoolbox}
\AtBeginEnvironment{algorithm}{\linespread{0.75}\selectfont}
\newtheorem{theorem}{Теорема}

\newtheorem{definition}{Определение}

%----------------------------------------------------------------
\begin{document}

\institution{%
Санкт-Петербургский государственный университет \\
Прикладная математика и информатика \\
Статистическое моделирование
}

\title{Конспект}

% Тема
\topic{\normalfont\scshape%
Фильтр Блума}

% Автор
\author{Кухтина Дарина Александровна}

% Город и год
\city{Санкт-Петербург}
\date{\number\year}

\maketitle

\tableofcontents
\intro
В последнее время объемы информации становятся очень большими, и для того, чтобы снизить затраты на ее обработку нужно использовать вероятностные методы. Ключевая их идея в том, что жертвую некоторой информацией можно значительно сократить время обработки запроса. Обычно они используются для уменьшения числа запросов к несуществующим данным в структуре с более дорогостоящим доступом (например, расположенной сетевой базе данных), то есть для "фильтрации" запросов к ней.\\
Таким образом, Фильтр Блума решает следующую задачу —- с помощью него можно достаточно быстро проверять содержится ли элемент в некотором множестве. При этом есть возможность получить ответ "да" , хотя элемент не содержится, но нет возможности получить ответ "нет" , когда он содержится.
\chapter{Основные понятия}
Фильтр Блума —- это реализация вероятностного множества, придуманная Бёртоном Блумом в 1970 году, позволяющая компактно хранить элементы и проверять принадлежность заданного элемента к множеству. 

Поясним что значит вероятностное множество.
\begin{definition}
Вероятностное множество —- структура данных, способная добавлять элемент в множество, а также выполнять запросы проверки принадлежности элемента множеству. При этом существует возможность получить или положительный ответ (однако в этом случае есть возможность ложноположительного срабатывания —- элемента в множестве нет, но структура данных сообщает, что он есть), или отрицательный определенный ответ (элемент точно не содержится в данном множестве).
\end{definition}
По сути, вероятностное множество это структура, позволяющая определить:
\begin{itemize}
\item элемент точно не принадлежит множеству
\item элемент принадлежит множеству с некоторой вероятностью.
\end{itemize}
Для определения Фильтра Блума также нужно дать определение хеш-функции. 
\begin{definition}
Хеширование — это преобразование массива (входных данных) определенной длины в выходную битовую строку (выходные данные) фиксированной длины. Функция, выполняющая данное преобразование называется хеш-функцией, значение хеш-функции называется хеш-код.
\end{definition}

Перейдем к определению Фильтра Блума.\\
Пусть у нас есть $n$ — количество элементов в множестве. Фильтр Блума представляет собой битовый массив из $m$ бит и $k$ различных хеш-функций $h_1 \dots h_k$, равновероятно отображающих элементы исходного множества во множество $\big\{ 0, 1, \dots m - 1 \big\}$, соответствующее номерам битов в массиве. Изначально, когда структура данных хранит пустое множество, все m бит обнулены.\\
Формализуем данное определение. У нас есть $kn$ независимых случайных величин $\xi_i$, равномерно распределенных на $(1,\ldots,m)$ — это наши $k$ хеш-функций на $n$ объектах. Так как значения хеш-функций должны быть вычислены по объекту, то мы считаем, что имеем реализацию $kn$- мерной случайной величины. При добавлении нового объекта мы добавляем еще $k$ случайных величин.\\
Пример: Гугл использует Фильтр Блума для выявления вредоносных URL. Ясно, что их очень много, и любой URL сначала
проходит через фильтр Блума, и только если фильтр дал положительный результат выполняется полная проверка принадлежности этого URL множеству вредоносных. Таким образом мы фильтруем большую часть безопасных URL и делаем запрос к множеству только в том случае, если если фильтр дал положительный ответ(помним про вероятность ложнопложительного срабатывания).
\chapter{Алгоритмы добавления элемента, проверки элемента множеству}
\section{Добавление элемента}
Опишем процедуру добавления элемента в Фильтр.
Входные параметры:
\begin{itemize}
\item
$m$ — размер битового массива, 
\item
$h_i$ — хеш-функции,
\item
$k$ — количество хеш-функций, 
\item
$n$ — количество элементов во множестве. 
\end{itemize}
Как было сказано выше — изначально все $m$ бит обнулены.\\
Для добавление элемента $e$ необходимо записать 1 на каждую из позиций $h_1(e), \ldots, h_k(e)$ битового массива.\\
Формально алгоритм на псевдокоде выглядит следующим образом:
\begin{algorithm}
\SetKwInOut{Input}{Входные данные}
\Input{$x$ -- объект для добавления, \\$B$ -- битовый массив фильтра}
\For{$j\leftarrow 1$ \KwTo $k$}{
  $i \leftarrow h_j(x)$\;
  \If{$B_i == 0$}{
    $B_i \leftarrow 1$\;
  }
}
\caption{Добавление элемента}
\end{algorithm}
\section{Пример}
Пусть $m$=7, размер нашего битового массива, $k=3$ — количество наших хеш-функций. Мы хотим добавить в пустой фильтр $F=\lbrace0,0,0,0,0,0,0\rbrace$ элемент $A$, для которого $h_1(A)=2$, $h_2(A)=3$ и $h_3(A)=6$. Тогда после добавления элемента $A$ в изначально пустой фильтр получим, что на позиции 2, 3 и 6 в массиве $F$ появятся единицы, то есть
$F=\lbrace0,1,1,0,0,1,0 \rbrace$.
\section{Проверка принадлежности элемента множеству}
Для того, чтобы проверить принадлежность элемента $c$ множеству, нужно проверить, что равны 1 все биты $h_1(c), \ldots, h_k(c)$ битового массива. Если хотя бы один из этих элементов равен нулю, то элемент не принадлежит массиву.\\
Формально алгоритм выглядит так:\\
\begin{algorithm}
\SetKwInOut{Input}{Входные данные}
\Input{$x$ -- объект для проверки, \\$B$ -- битовый массив фильтра}
$l \leftarrow 1$, $j \leftarrow 1$\;
\While{$m == 1$ and $j < k$}{
  \If{$B_i == 0$}{
    $l \leftarrow 0$\;
  }
  $j \leftarrow j+1$\;
}
\Return{$l$}
\caption{Проверка элемента}
\end{algorithm}
Видно, что алгоритм может допустить ложноположительное срабатывание — считаем, что элемент принадлежит множеству, хотя он не принадлежит. В этом случае 1 на местах $h_1(c), \ldots, h_k(c)$ появились в результате добавления других элементов:
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{Bloom_filter.png}\\ 
\end{center}
\caption{C не принадлежит множеству!} 
\end{figure}
Также стоит отметить что алгоритм не допускает ложноотрицательного срабатывания — считаем, что элемент не принадлежит множеству, хотя он принадлежит. Это полезное свойство следует напрямую из алгоритма добавления элемента.
\chapter{Минимизация ложноположительного срабатывания}
Ложноположительным срабатыванием мы называем ситуацию, когда фильтр говорит, что объект принадлежит множеству, но на самом деле это не так — все проверяемые биты заполнены при добавлении других элементов. 
Ясно, что мы хотим уменьшить вероятность такого события. \\
Рассмотрим событие $B_j=\lbrace\xi_i=j$ хотя бы для одного $i=1,\ldots,nk\rbrace$, $j=1,\ldots, m$. $P(B_j)=1-(1-\frac{1}{m})^{nk}$
Формально задача сводится к вычислению вероятности $P(B_1,\ldots,B_k)\approx P(B_1) \times \ldots \times P(B_k)=(1-(1-\frac{1}{m})^{nk})^k$.\\
Мы определили чему равно вероятность ложноположительного срабатывания,и хотим ее минимизировать. То есть $(1-(1-\frac{1}{m})^{nk})^k \rightarrow min$. Для достаточно большого m в силу второго замечательного предела имеем:$(1-(1-\frac{1}{m})^{kn})^k \approx (1-\exp^{-\frac{kn}{m}})^k$. Минимизирую, получаем $k_{opt}=\frac{m}{n}ln(2)$.
\chapter{Выбор ключевых параметров}
Выбор параметров играет большую роль для минимизации ложноположительного срабатывания. Рассмотрим что произойдет при увеличении значений параметров? Зафиксируем оптимальное количество хеш-фенкций $k=k_{opt}$. Вспомним, что вероятность
ложноположительного срабатывания при фиксированном $k_{opt}$ равна: $P=(1-\exp^{-\frac{k_{opt}n}{m}})^{k_{opt}}$. Следовательно:
\begin{itemize}
\item
$m$ — размер битового массива — чем больше, тем меньше вероятность ложноположительного срабатывания
\item
$n$ — число элементов в множестве — чем больше, тем больше вероятность ложноположительного срабатывания.
\end{itemize}
Хеш-функция является ключевым элементом вероятностного фильтра. Заметим , что для фильтра Блума вероятность ложноположительного срабатывания зависит только от отношения $\frac{m}{n}$, и не зависит от выбора хеш-функции. Однако для уменьшения времени и увеличенения мощности выбор хеш-функции играет важную роль. Учитывая объемы данных это стоит принять во внимание.\\
Вообще, мы можем использовать только две независимые хеш-функции $h_1$ и $h_2$ для того, чтобы сгенерировать $k$ хеш-функций по следующей формуле: $g_i(x)=h_1(x)+ih_2(x)$.\\
Стоит также отметить, что если мы хотим, чтобы вероятность ложноположительного срабатывания была равна какому-то, заранее заданному, $p$, то для построения фильтра нужно $k=-\frac{\ln(p)}{\ln(2)}$ --- хеш-функций. Размер битового массива $m=-\frac{n \ln(p)}{(\ln(2))^2}$  
\chapter{Теоретические результаты}
Вообще говоря равенство $P(B_1,\ldots,B_k)\approx P(B_1)\times \ldots P(B_k)$ не является точным, потому что нет независимости.\\
Поэтому вероятность ложноположительного срабатывания $(1-(1-\frac{1}{m})^{nk})^k$ является вообще говоря, заниженной оценкой. Однако, мы можем ограничить ее сверху. Есть теоретический результат.
\begin{theorem}
Пусть $p_{n,m,k}$ — вероятность ложноположительного срабатывания для Фильтра Блума, где $m$ — размер битового массива, $n$ —- число элементов в множестве,$k$ —- количество хеш-функций, $k \geq 2$. Обозначим $p=1-(1-\frac{1}{m})^{kn}$ Тогда\\
$p^k$<$p_{n,m,k} \leq p^k (1+O(\frac{k}{p}\sqrt{\frac{ln(m)-k ln(p)}{m}}))$
\end{theorem}
Таким образом, ошибка в действительности больше, чем $(1-(1-\frac{1}{m})^{kn})^k$. Однако верхняя оценка показывает, что при достаточно больших $m$ и при достаточно малых $k$ она практически равна ей.
\chapter{Минусы фильтра Блума}
К минусам Фильра Блума можно отнести следующее:
\begin{enumerate}
\item
Стандартный Фильтр Блума не поддерживает операцию удаления элемента (решается модификацией)
\item
Фильтр Блума эффективен для больших $m$. В других случаях хеш-таблица оказывается эффективнее, так как работает за константное время и не возникает ложноотрицательного срабатывания.
\end{enumerate}
\chapter{Операции над Фильтрами Блума}
Как было сказано ранее, стандартный фильтр Блума не поддерживает операции удаления элементов. Возможно поддержание операции удаления элемента из фильтра, если использовать второй фильтр Блума который будет хранить удаленные элементы. Проблема этого подхода состоит в том, что для второго фильтра также возможно ложноположительное срабатываение, что в свою очередь приведет к тому, что для перового фильтра будет ложноотрицательное срабатывание — то есть мы получим, что элемента нет в фильтре, хотя он не был удален. Естественно такой подход не является хорошим. Однако, Фильтр Блума поддерживает операции объедининения и пересечения. Это может быть выполнено при условии, что они одинакового размера и с одинаковым набором хеш-функций. Эти операции могут быть реализованы путем побитовых операций объединения и пересечения. При этом вероятность ложноположительного срабатывания объединения будет больше или равна вероятности ложноположительного срабатывания для каждого из фильтров в отдельности.

\section{ Фильтра Блума: удаление элемента}
Для стандартного фильтра Блума невозможна операция удаления элемента. Однако было бы довольно удобно, если бы фильтр поддерживал данную операцию. Это возможно, если используется модификация фильтра Блума со счетчиками. При добавлении элемента мы увеличиваем счетчик, при удалении элемента — уменьшаем. Формально алгоритм добавления для модификации Фильтра Блума со счетчиками выглядит так:\\

\begin{algorithm}[ht!]
\SetKwInOut{Input}{Входные данные}
\Input{$x$ -- объект для добавления, \\$B$ -- битовый массив, \\$C$ -- массив счетчиков}
\For{$j \leftarrow 1$ \KwTo $k$}{
  $i \leftarrow h_j(x)$\;
  $C_i \leftarrow C_i+1$\;
  \If{$B_i == 0$}{
    $B_i \leftarrow 1$\;
  }
}
\caption{Добавление элемента в фильтр Блума со счётчиками}\label{alg:add to filter with counter}
\end{algorithm}
\newpage
Рассмотрим также удаление элемента из Фильтра:
\begin{algorithm}[ht!]
\SetKwInOut{Input}{Входные данные}
\Input{$x$ -- объект для удаления, \\$B$ -- битовый массив, \\$C$ -- массив счетчиков}
\For{$j \leftarrow 1$ \KwTo $k$}{
  $i \leftarrow h_j(x)$\;
  $C_i \leftarrow C_i-1$\;
  \If{$C_i \leq 0$}{
    $B_i \leftarrow 0$\;
  }
}
\caption{Удаление элемента из фильтра Блума со счётчиками}\label{alg:delete from filter with counter}
\end{algorithm}

Поиск элемента происходит таким же образом, что и для стандартного фильтра Блума.


\end{document}
