\documentclass[specialist,
               substylefile = spbu.rtx,
               subf,href,colorlinks=true, 12pt]{disser}

\usepackage[a4paper,
            mag=1000, includefoot,
            left=3cm, right=1.5cm, top=2cm, bottom=2cm, headsep=1cm, footskip=1cm]{geometry}
\usepackage[T2A]{fontenc}
%\usepackage{ucs}
\usepackage[cp1251]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{array}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{footnote}
\usepackage{breakurl} 
\usepackage{url}
\usepackage{amssymb}
\usepackage{mathtools}
%\usepackage{subfigure}
\usepackage{xcolor}
\usepackage{tipa}
\usepackage{upgreek}
\usepackage{listings}
\usepackage{longtable}
\usepackage{caption}
%\hypnenation{гамма--рас-пре-де-ле-ние}
\usepackage{textcomp}
\DeclareCaptionFont{white}{\color{white}} %делает текст заголовка белым
%код ниже нарисует серую рамочку вокруг заголовка кода
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\usepackage{marvosym}
\usepackage{amsthm}
\newtheorem{mydef}{Определение}
\newtheorem{myth}{Теорема}
\newtheorem{mynote}{Замечание}
\newtheorem{mylemma}{Лемма}
\newtheorem{myexample}{Пример}
\DeclareMathOperator{\h}{h}
\DeclareMathOperator{\const}{const}
\DeclareMathOperator{\argmin}{argmin}
%\DeclareMathOperator{\max}{max}
\ifpdf\usepackage{epstopdf}\fi

\bibliographystyle{gost2008}
% Точка с запятой в качестве разделителя между номерами цитирований
%\setcitestyle{semicolon}

% Использовать полужирное начертание для векторов
\let\vec=\mathbf

% Включать подсекции в оглавление
\setcounter{tocdepth}{2}

\graphicspath{{fig/}}

%----------------------------------------------------------------
\begin{document}

% Название организации
\institution{%
    Санкт-Петербургский государственный университет \\
    Математико--механический факультет \\
    Кафедра статистического моделирования
}

% Имя лица, допускающего к защите (зав. кафедрой)
%\apname{д.\,ф.-м.\,н., профессор С.\,М.~Ермаков}

\title{Конспект}

% Тема
\topic{\normalfont\scshape%
     Построение минимальных идеальных хэш--функций с помощью случайных графов}

% Автор
\author{Алиева Наталия Дмитриевна}

% Научный руководитель
%\sa       {М.\,С.~Ермаков}
%\sastatus {д.\,ф.-м.\,н., профессор}

% Город и год
\city{Санкт-Петербург}
\date{\number\year}

\maketitle

\tableofcontents

\intro

Сегодня приходится работать с большими объемами данных, и с каждым днем их становится все больше. В следствие этого  для экономии ресурсов требуется эффективно хранить имеющиеся данные. Кроме того, возникает необходимость быстрого быстрого доступа к каким--либо элементам наборов данных.

\textbf{Минимальные идеальные хэширующие функции (minimal perfect hash functions)} --- один из инструментов, который помогает решить такую проблему. Такие функции широко применяются во многих сферах, например:

\begin{itemize}
\item естественные языки,
\item зарезервированные слова в языке программирования,
\item URLs,
\item Data Mining: нестандартные взаимосвязи между переменными в больших базах данных.
\end{itemize}

В этом отчете будет рассматриваться задача построения минимальных идеальных хэш--функций с помощью случайных графов на примере одного из алгоритмов.

\newpage

\section{Вспомогательные определения}

\subsection{Графы}



\subsection{Хэш-функции}

если потребуется

\newpage

\section{Построение минимальных идеальных хэш--функций}

Здесь и далее представлен метод построения минимальных идеальных хэш--функций \textbf{MOS}, основанный на случайных графах. Метод состоит из следующих этапов:

\begin{itemize}
\item \textbf{Mapping}: преобразует множество ключей из исходного объединения в новое.
\item \textbf{Ordering}: помещает ключи в последовательно, определяя порядок, в котором хэш--значения будут присваиваться ключам.
\item \textbf{Searching}: пытается присвоить хэш--значения ключам.
\end{itemize} 

Для начала введем все обозначения. Пусть $h$ --- minimal perfect hash function, которую хотим построить. 

Рассмотрим 2 вспомогательные случайные функции $h_1, h_2 : U \longrightarrow V$, где $V = [0; t-1]$ для некоторого выбранного подходящего целого $t = cn$, где $n = |S|$. Построим случайный граф $G = G(h_1, h_2)$ на $V$ такой, что: $E(G) = \{\{h_1(x),h_2(x)\}: x \in S\}$. Для каждого ключа в множестве ключей $S$ существует ребро в графе $G$.

Из вышесказанного следует, что нас интересует максимальный подграф графа $G$ сo степенью не меньше 2. Такой подграф будем называть \textbf{критическим подграфом} графа $G$ и обозначим его как $G_{crit}$. Вершины и ребра такого подграфа также называются \textbf{критическими}: $V_{crit} = V(G_{crit})$, $E_{crit} = E(G_{crit})$. Кроме того, дополнения к множеству критических вершин и ребер будем называть \textbf{некритическими вершинами и ребрами}: $V_{ncrit} = V \setminus V_{crit}$, $E_{ncrit} = E \setminus E_{crit}$. Введем также $V_{scrit} \subseteq V_{crit}$ --- множество всех критических вершин, у которых есть хотя бы одна некритическая вершина в качестве соседа. Таким образом, \textbf{некритический подграф}графа $G$ построен следующим образом: $G_{ncrit} = (V_{ncrit} \cup V_{scrit}, E_{ncrit})$. Некритический подграф относится к акицличной части графа. В итоге получаем $G = G_{crit} \cup G_{ncrit}$.

Построим теперь подходящую маркировку $g : V \longrightarrow \mathbb{Z}$ для вершин графа $G$: для каждой $v \in G$ выбираем такую $g(v)$, что $h(x) = g(h_1(x)) + g(h_2(x))$ (при $x \in S$) --- минимальная идеальная функция хэширования для $S$.

В итоге рассматриваемый алгоритм действует следующим образом: на вход он получает множество ключей $S$, а в качестве результата возвращает маркировку $g$. Представим далее каждый шаг более подробно.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{imgs/proc.jpg}
\caption{Основные шаги алгоритма по построению минимальных идеальных хэш--функций}
\end{center}
\end{figure}

\subsection{Mapping step}

Шаг $Mapping (S, G)$ получает на вход множество ключей $S$ и строит случайный граф $G = G(h_1, h_2)$  с помощью построения 2--х вспомогательных функций $h_1, h_2 : U \longrightarrow [0;t - 1]$.

Рассмотрим построение функций $h_1, h_2$. Пусть $L$ --- некоторая верхняя граница длин ключей в $S$. 

\textbf{TODO}

\newpage

\subsection{Ordering step}

Процедура упорядочивания $Ordering (G, G_{crit}, G_{ncrit})$ получает на вход граф $G$ и на выходе возвращает два подграфа: критический $G_{crit}$ и некритический $G_{ncrit}$ такие, что $G = G_{crit} \cup G_{ncrit}$. Чтобы достичь этого результата, будем итеративно удалять все вершины степени 1, пока таковых не останется. Рассмотрим действие этого шага алгоритма на примере.

\begin{myexample}
Рассмотрим граф с 9--ю вершинами и 8--ю ребрами, где степень вершины \textbf{d} для каждой вершины указана над соответствующей вершиной.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{imgs/ex2.jpg}\label{im:ex2}
\caption{Пример разбиения исходного графа на два подграфа: критический и некритический}
\end{center}
\end{figure}

Применяя шаг упорядочивания к графу на рисунке ~\ref{im:ex2}, в итоге оценили граф из 5--ти вершин. Получили, что все вершини степени 0 являются некритическими вершинами, а все остальные --- критическими. Чтобы определить вершины множества $V_{scrit}$, соберем все вершины $v \in V(G_{crit})$, у каждого из которых хотя бы одна вершина принадлежит списку смежных вершин для $v$ и множеству $V(G_ncrit)$, как вершина 8 на рисунке ~\ref{im:ex2}.
\end{myexample}

Отметим, что временная сложность этого шага $\mathcal{O}(|V(G)|)$. Так как $|V(G)| = t = cn$, этап упорядочивания происходит за время $\mathcal{O}(n)$.

\newpage

\subsection{Searching step}

На шаге $Searching (G, G_{crit}, G_{ncrit}, g)$ на вход подаются исходный граф $G$ и подграфы $G_{crit}, G_{ncrit}$, и процедура поиска ищет подходящее значение в массиве $g$ для каждой вершины $v \in V(G)$. Сначала на этом шаге обрабатываются вершины критического подграфа $G_{crit}$, а затем вершины некритического подграфа $G_{ncrit}$. Это необходимо, чтобы разрешить все переобозначения как можно раньше (такие переобозначения могут быть вследствие наличия циклов в подграфе).

\subsubsection{Присваивание значений для критических вершин}

Метки $g(v) (v \in V(G_{crit}))$ назначаются в порядке возрастания, следуя жадной стратегии, где критические вершины рассматриваются по одному, согласно поиску в ширину в подграфе $G_{crit}$. Если предлагаемое значение $x$ для $g(v)$ запрещено (такое присвоение $g(v) = x$ создаст 2 ребра с одинаковым весом), тогда увеличиваем $x$ на 1 и пробуем присвоить $g(v)$ $x+1$. 

Пусть множество $A_E$ --- множество адресов, присвоенных ребрам в $E(G_{crit})$. Изначально $A_E = \emptyset$. Пусть $x$ --- кандидат для $g(v)$. Изначально $x = 0$. Считая, что подграф $G_{crit}$ имеет вид~\ref{im:ex2}, рассмотрим пошаговый пример присваивания значений вершинам в подграфе $G_{crit}$ на рисунке~\ref{im:ex3}. 

Итак, у нас выбрана вершина $v$, необходимо присвоить предлагаемое значение $x$ в случае успеха, затем увеличит $x$ на 1 и так далее. Допустим, выбранная вершина -- \textbf{№8}, значит $g(8) = 0$, и $x$ становится 1. Теперь рассмотрим все вершины из списка смежности для вершины \textbf{№8}. Сначала рассмотрим вершину \textbf{№0}. В этом случае соберем в множество $Y$ те вершины, которые уже имеют присвоенное значение $x$ и которые смежные к \textbf{№0}, т.е. $Y = \{8\}$. Далее для всех $u \in Y$ проверяем условие: $g(u) + x \notin A_E$.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{imgs/ex3.jpg}\label{im:ex3}
\caption{Пример присваивания значений вершинам критического подграфа}
\end{center}
\end{figure}


Так как $g(8) + 1 = 1 \notin A_E$, значит 1 присваивается $g(0)$, $x$ становится 2, и пополняется множество $A_E$: $A_E = A_E \cup \{1\} = \{1\}$. Далее рассматриваем вершину \textbf{№3}, $g(3)$ присваивается 2,  и $A_E = A_E \cup \{2\} = \{1,2\}$. Затем достигается вершина \textbf{№4}, и $Y = \{3,8\}$. Так как $g(3) + 3 = 5 \notin A_E$ т $g(8) + 3 = 3 \notin A_E$, тогда $g(4)$ присваивается 3, а $A_E = A_E \cup \{3,5\} = \{1,2,3,5\}$. Наконец, достигли вершины \textbf{№7}, и $Y = \{0,8\}$. $g(0) + 4 = 5 \in A_E$, $x$ увеличивается на 1 ($x = 5$). $g(8) + 5 = 5 \in A_E$, тогда $x$ еще увеличивается на 1 ($x = 6$). Снова проверяем: $g(0) + 6 = 7 \notin A_E$ и $g(8) + 6 = 6 \notin A_E$, тогда $g(7)$ присваивается 6, кроме того, $A_E = A_E \cup \{6,7\} = \{1,2,3,5,6,7\}$. Этим завершается алгоритм, так как все вершины критического подграфа рассмотрены.

\subsubsection{Присваивание значений для некритических вершин}

В этом случае мы производим назначение значений к вершинам некритического подграфа из неиспользованных значений на предыдущем шаге. Поэтому начинаем поиск в глубину в $V_{scrit}$, так как метки $g$ на эти вершины уже расставлены и не могут меняться. Считая некритический подграф таким, как на рисунке~\ref{im:ex2} рассмотрим пошаговый пример присвоения значений.Выбираем вершину, с которой начнем (в данном случае снова \textbf{№8}) и идем последовательно.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{imgs/ex4.jpg}\label{im:ex4}
\caption{Пример присваивания значений вершинам некритического подграфа}
\end{center}
\end{figure}

В предыдущем примере остались неиспользованными вершины $\{0,4\}$. Таким образом, берем 0 --- как первый неиспользованный адрес и вершину \textbf{№1} --- как вершину, смежную к \textbf{№8}. $0 - g(8) = 0$ (``адрес'' - ``значение в исходной вершине''), поэтому $g(1)$ присваивается 0. И единственная неохваченная вершина: $4 - g(1) = 4$, поэтому $g(2)$ присваиваем 4. Свободным вершинам присваивается 0. Процесс продолжается, пока список неотмеченных вершин не пуст.

\end{document}

