<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#определения">Определения</a></li>
<li><a href="#fmoc">$ -FMOC $</a></li>
<li><a href="#факторизация">Факторизация</a></li>
<li><a href="#математическая-постановка-задачи.">Математическая постановка задачи.</a></li>
<li><a href="#алгоритм">Алгоритм</a></li>
<li><a href="#сравнение-с-модельными-данными">Сравнение с модельными данными</a></li>
</ul>
</div>
<p><a href="http://is.tuebingen.mpg.de/fileadmin/user_upload/files/publications/2011/UAI-2011-Peters.pdf">Исходная статья: Identifiability of Causal Graphs using Functional Models</a> - <em>Отличается от первоначально выбранной!</em></p>
<p>Популярным средством измерения силы причинно-следственной связи процессов, протекающих в природе или обществе, является корреляция. Однако существует принцип, который формулируется довольно просто: “correlation does not mean causation”. Пренебрежение им может порождать так называемые «ложные корреляции»: например, количество гнёзд аистов влияет на рождаемость в европейских странах или количество фильмов, в которых снялся Николас Кейдж, может быть каким-то образом связано с гибелью людей в бассейнах. <img src="http://i.imgur.com/sKwYC0Y.png" alt="Storks" /> <img src="http://i.imgur.com/DvqDAbM.png" alt="Nicolas Cage" /></p>
<p>Возникает естественный вопрос: в каких случаях “correlation DOES mean causation”? На этот вопрос пытается ответить <a href="https://ei.is.tuebingen.mpg.de/research_groups/causal-inference-group">группа исследователей из Института интеллектуальных система Макса Планка.</a> Оказывается, при выполнении некоторых условий, можно восстановить причинно-следственную связь из результатов наблюдений.</p>
<p>Для исследования причинно-следственных связей между процессами <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%BB,_%D0%94%D0%B6%D1%83%D0%B4%D0%B0">Джуда Пёрл</a> предложил фунцкиональные причинные модели (functional causal models). По уравнениям, описывающим причинную модель, можно построить граф, который отображает зависимости между случайными величинами, но не описывает характера таких зависимостей. Таким образом, граф содержит меньше информации о модели, однако позволяет ввести в терминах теории графов некоторые критерии, упрощающие определение условной независимости между переменными. Эти понятия неразрывно связаны с понятием байесовских сетей. В 2011 году Перл стал лауреатом Премии Тьюринга за «фундаментальный вклад в искусственный интеллект посредством разработки исчисления для проведения вероятностных и причинно-следственных рассуждений».</p>
<p>PC-алгоритм (Peter-Clark) находит частично ориентированное остовное дерево причинного графа, соответствующего классу марковской эквивалентности истинного графа. Алгоритм основан на тестировании условной независимости (CIB, conditional independence-based), его описание можно найти в книге “Causation, Prediction, and Search” Peter Spirtes, Clark Glymour, and Richard Scheines (2001). Имеется реализация алгоритма на языке R в пакете <code>pcalg</code> (функция <code>pc</code>).</p>
<h3 id="определения">Определения</h3>
<p>Ориентированный ациклический граф (DAG, directed acyclic graph) — это ориентированный граф, в котором отсутствуют направленные циклы, то есть пути, начинающиеся и кончающиеся в одной и той же вершине.</p>
<p>Пусть $ (X_i)_{i V} $ — семейство случайных величин, $ G = (V, E) $ — DAG с вершинами $ E V^2 $. Как правило, в литературе используют обозначения $ X_i $ и $ i $ для соответствующих вершин графа.</p>
<p>$ X_i $ называется вершиной-родителем вершины $ X_j $ если $ (i, j) E $ и вершиной-ребёнком, если $ (j, i) E $. Множество вершин-родителей вершины $ X_j $ обозначатся $ pa_j $, множество вершин-детей — $ ch_j $.</p>
<p>Если $ (i, j) E $ и $ (k, j) E $, $ j $ называется <em>коллайдером</em>.</p>
<p>Направленным путём в графе $ G $ называется последовательность различных вершин $ X_{i_1}, …, X_{i_n} $, для которых $ (i_k, i_{k+1}) E $ или $ (i_{k+1}, i_k) E $ для $ k = 1, …, n - 1 $. Если между вершинами $ X_{i_1} $ и $ X_{i_n} $ есть направленный путь, вершина $ X_{i_n} $ называется потомком вершины $ X_{i_1} $. Множество всех потомков вершины $ X_i $ обозначается $ de_i $, множество вершин-не-потомков — $ nd_i $.</p>
<p>Путь между $ X_{i_1} $ и $ X_{i_n} $ называется заблокированным множеством $ S $ (не включая ни $ X_{i_1} $, ни $ X_{i_n} $), если существует такая вершина $ X_{i_k} $, что выполняется одно из условий: 1. $ X_{i_k} S $ и - $ X_{i_{k-1}} X_{i_k} X_{i_{k+1}} $ или - $ X_{i_{k-1}} X_{i_k} X_{i_{k+1}} $ или - $ X_{i_{k-1}} X_{i_k} X_{i_{k+1}} $ 2. $ X_{i_{k-1}} X_{i_k} X_{i_{k+1}} $ и ни $ X_{i_k} $, ни её потомки не принадлежат $ S $.</p>
<p>Говорят, что два непересекающихся множества вершин $ A $ и $ B $ d-разделены (непересекающимся с ними множеством $ S $), если каждый путь между вершинами $ A $ и $ B $ заблокирован множеством $ S $.</p>
<p>Совместное распределение $ ^{(X_i)_{i V}} $ называется марковым относительно DAG $ G $, если $ A $ и $ B $ d-разделены $ C $ $ A ⫫ B C $ для всех непересекающихся множеств $ A, B, C $.</p>
<p>$ ^{(X_i)_{i V}} $ называется достоверным (faihful) относительно DAG G, если $ A, B $ d-разделены $ C $ $ A ⫫ B C $ для всех непересекающихся множеств $ A, B, C $.</p>
<p>Два графа называются марковски эквивалентными, если в них выполняются одинаковые наборы d-разделимости, т. е. имеют одинаковые наборы условных независимостей.</p>
<p><em>TODO: примеры эквивалентности, faihfulness</em></p>
<h3 id="fmoc">$ -FMOC $</h3>
<p>Функциональной моделью (functional model, structural equation model) называются $ V $ уравнений вида <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>p</mi><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>∈</mo><mi>V</mi><mo>,</mo></mrow><annotation encoding="application/x-tex"> X_i = f_i(pa_i, N_i), \quad i \in V, </annotation></semantics></math> где $ pa_i V  $ и $ (N_i)_{i V} $ взаимно независимо распределены по $ ^{N_i} $, и граф, полученный построением направленных рёбер от элементов $ pa_i $ к $ X_i $, $ i V $, ацикличен.</p>
<p>$ -FMOC $ (functional model class with function class $  $) называется классом функциональных моделей с классом функций $  $, если для заданного класса функций $   $ $ f_i , i V $ каждая модель порождает абсолютно непрерывную относительно меры Лебега $ ^{(X_i), i V} $.</p>
<p>Каждая функциональная модель порождает уникальное совместное распределение $ ^{(X_i), i V} $.</p>
<h3 id="факторизация">Факторизация</h3>
<p>Граф, полученный из функциональной модели, позволяет факторизовать совместную плотность распределения по следующей формуле:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℙ</mi></mstyle><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>i</mi><mo>∈</mo><mi>V</mi></mrow></msup><mo>=</mo><mi>p</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munder><mo>∏</mo><mi>j</mi></munder><mi>p</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>j</mi></msub><mo>∣</mo><mi>p</mi><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathbb{P}^{(X_i), i \in V} = p(X_1, ..., X_n) = \prod_j p(X_j \mid pa_j) </annotation></semantics></math></p>
<h3 id="математическая-постановка-задачи.">Математическая постановка задачи.</h3>
<p>Пусть $ (X_i)_{i V} $ — конечный набор случайных величин.</p>
<p><strong>Задача</strong>: по i.i.d. выборкам из совместного распределения $ ^{(X_i)_{i V}} $ восстановить DAG $ G_c $ процесса, породившего эти данные.</p>
<p>Похожим образом была поставлена задача в одном из соревнований Kaggle: https://www.kaggle.com/c/cause-effect-pairs/. В нём участникам предлагалось по заданным парам определеить, что из них является причиной, а что — следствием. Эти наборы данных были получены из различных предметных областей из процессов, в которых причинно-следственные связи уже известны. Чтобы усложнить задачу, к данным были добавлены наборы зависимых, но не являющихся непосредственными причинами друг друга процессов, а также искуственно сгенерированные пары.</p>
<p>Согласно теореме, приведённой в статье, структура причинного графа может быть определена из совместного распределения с точностью до класса (марковской) эквивалентности, если выполняются условия марковости и достоверности. В этих условиях работает, например, алгоритм PC.</p>
<p><strong>Лемма</strong> Можно показать, что следующие пары могут быть различены ($   $): 1. (линейные модели с аддитивным шумом) $ _1 = { f(x, n) = ax + n} $; 2. (дискретные модели с аддитивным шумом) $ _1 = { f(x, n) = (x) + n } $; 3. (нелинейные модели с аддитивным шумом) $ _1 = { f(x, n) = (x) + n} $.</p>
<p><strong>Теорема</strong> Пусть $ ^{(X_i), i V} $ порождено функциональной моделью из $ -IFMOC $ с графом $ G $. Тогда оно не может быть порождено функциональной моделью из $ -IFMOC $, которому соответствует другой граф $ G’ G $.</p>
<p><strong>Следствие:</strong> Если процесс, порождающий выборку, принадлежит $ -IFMOC $ с графом $ G = G_c $ (т. е. $ pa_i $ являются непосредственными причинами $ X_i $), то истинный причинный DAG $ G_c $ может быть восстановлен по совместному распределению $ ^{(X_i), i V} $.</p>
<h3 id="алгоритм">Алгоритм</h3>
<p>Алгоритм обучает функциональную модель для всех возможных конфигураций графа и выводит те из них, для которых остатки оказываются независимыми от регрессоров.</p>
<p>_$ _1, …, <em>d $ задают порядок.</em></p>
<p>_Что такое $ <em>i $?</em></p>
<p>Алгоритм не указывает, какую модель регрессии следует обучать в процессе работы. Конкретный вид модели следует подбирать из дополнительных знаний о природе наблюдаемого процесса. Кроме того, следует выбрать критерий определения независимости двух выборок.</p>
<p><img src="http://i.imgur.com/ZOYW8bi.png" alt="Algo 1" /> <img src="http://i.imgur.com/pPYipwA.png" alt="Algo 2" /></p>
<p>В случаях, когда нет подходящих графов, соответствующих причинной структуре данных, или их больше одного, алгоритм полагает, что нарушены условия теоремы 2, и сообщает, что он не способен выбрать определённую модель для вывода в качестве результата.</p>
<p>Разумеется, конечная выборка не является точным описанием $ ^{(X_i)_{i V}} $. Авторы статьи не приводят оценок качества работы алгоритма в зависимости от размера входной выборки.</p>
<h3 id="сравнение-с-модельными-данными">Сравнение с модельными данными</h3>
<p>Авторы проверяют точность работы алгоритма на тестовых наборах данных, сгенерированных i.i.d. из моделей, состоящих из четырёх уравнений, и сравнивают результаты работы с алгоритмом PC.</p>
<p>Авторы использовали модели линейной регрессии и <a href="http://gaussianprocess.org/gpml/">Gaussian Process</a>, а для тестирования независимости остатков использовали Hilbert-Schmidt independence criterion.</p>
<p>В случаях, когда выполняются требования марковости и достоверности выполняются, предлагаемый авторами алгоритм совершает меньше ошибок. Если требование достоверности не выполняется, алгоритм PC всегда ошибается, в то время как предложенный алгоритм продолжает выдавать корректные результаты. Если оба требования нарушены, алгоритм PC выдаёт неправильные результаты; предложенный алгоритм сообщает, что не способен определить структуру.</p>
</body>
</html>
